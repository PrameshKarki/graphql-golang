package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.39

import (
	"context"
	"fmt"

	"github.com/PrameshKarki/event-management-golang/graph/model"
	expenseService "github.com/PrameshKarki/event-management-golang/graph/services/expense"
	userEventService "github.com/PrameshKarki/event-management-golang/graph/services/userEvents"
	"github.com/PrameshKarki/event-management-golang/utils"
)

// AddExpense is the resolver for the addExpense field.
func (r *mutationResolver) AddExpense(ctx context.Context, eventID string, data model.ExpenseInput) (*model.Response, error) {
	_, err := expenseService.CreateExpense(eventID, data)
	if err != nil {
		return nil, err
	} else {
		return &model.Response{Success: true, Message: "Expense added to the event successfully."}, nil
	}
}

// DeleteExpense is the resolver for the deleteExpense field.
func (r *mutationResolver) DeleteExpense(ctx context.Context, id string) (*model.Response, error) {
	// Only admin and owner can delete the expense
	allowedRoles := []string{"ADMIN", "OWNER"}
	userID := ctx.Value("user").(*utils.TokenMetadata).ID
	associatedEvent, _ := expenseService.GetEventID(id)
	userRole, _ := userEventService.GetRoleOfUser(userID, associatedEvent)
	hasPermission := utils.Includes(allowedRoles, userRole)

	if !hasPermission {
		return nil, fmt.Errorf("you don't have permission to remove the expense. Please contact the event owner to remove it")
	}
	_, err := expenseService.RemoveExpense(id)
	if err != nil {
		return nil, err
	} else {
		return &model.Response{Success: true, Message: "Expense deleted successfully."}, nil
	}
}

// UpdateExpense is the resolver for the updateExpense field.
func (r *mutationResolver) UpdateExpense(ctx context.Context, id string, data model.ExpenseInput) (*model.Response, error) {
	allowedRoles := []string{"ADMIN", "OWNER"}
	userID := ctx.Value("user").(*utils.TokenMetadata).ID
	associatedEvent, _ := expenseService.GetEventID(id)
	userRole, _ := userEventService.GetRoleOfUser(userID, associatedEvent)
	hasPermission := utils.Includes(allowedRoles, userRole)

	if !hasPermission {
		return nil, fmt.Errorf("you don't have permission to remove the expense. Please contact the event owner to remove it")
	}
	_, err := expenseService.UpdateExpense(id, data)
	if err != nil {
		return nil, err
	} else {
		return &model.Response{Success: true, Message: "Expense updated successfully."}, nil
	}
}

// GetExpensesOfEvent is the resolver for the getExpensesOfEvent field.
func (r *queryResolver) GetExpensesOfEvent(ctx context.Context, eventID string) ([]*model.Expense, error) {
	return expenseService.GetExpensesOfEvent(eventID)
}

// GetExpense is the resolver for the getExpense field.
func (r *queryResolver) GetExpense(ctx context.Context, id string) (*model.ExpenseWithEvent, error) {
	return expenseService.GetExpense(id)
}

// GetExpensesByCategory is the resolver for the getExpensesByCategory field.
func (r *queryResolver) GetExpensesByCategory(ctx context.Context, eventID string) ([]*model.ExpensesByCategory, error) {
	userID := ctx.Value("user").(*utils.TokenMetadata).ID
	allowedRoles := []string{"ADMIN", "OWNER", "CONTRIBUTOR"}
	userRole, _ := userEventService.GetRoleOfUser(userID, eventID)
	hasPermission := utils.Includes(allowedRoles, userRole)
	if !hasPermission {
		return nil, fmt.Errorf("you don't have permission to view the expenses")
	}
	return expenseService.SumOfExpenseByCategory(eventID)
}
